<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>カスタムタイマー</title>
    <link rel="stylesheet" href="style.css"> </head>
<body>
    <h1>カスタムタイマー</h1>

    <div class="all-reset-container">
        <button class="all-reset-button" onclick="resetAllTimers()">全タイマーをリセット</button>
    </div>

    <div class="timer-section feature1-outer-section">
        <h2>機能1: 固定2回</h2>

        <div class="feature1-item" id="timerSection1">
            <h3>タイマー 1-1</h3>
            <div class="timer-controls">
                <button onclick="startTimer1(1)">スタート</button>
            </div>
            <div class="current-status-group">
                <div class="current-status" id="status1"></div>
                <div class="next-beep-time" id="nextBeep1"></div>
            </div>
        </div>

        <div class="feature1-item" id="timerSection2">
            <h3>タイマー 1-2</h3>
            <div class="timer-controls">
                <button onclick="startTimer1(2)">スタート</button>
            </div>
            <div class="current-status-group">
                <div class="current-status" id="status2"></div>
                <div class="next-beep-time" id="nextBeep2"></div>
            </div>
        </div>

        <div class="feature1-item" id="timerSection3">
            <h3>タイマー 1-3</h3>
            <div class="timer-controls">
                <button onclick="startTimer1(3)">スタート</button>
            </div>
            <div class="current-status-group">
                <div class="current-status" id="status3"></div>
                <div class="next-beep-time" id="nextBeep3"></div>
            </div>
        </div>

        <div class="feature1-item" id="timerSection4">
            <h3>タイマー 1-4</h3>
            <div class="timer-controls">
                <button onclick="startTimer1(4)">スタート</button>
            </div>
            <div class="current-status-group">
                <div class="current-status" id="status4"></div>
                <div class="next-beep-time" id="nextBeep4"></div>
            </div>
        </div>
    </div> <div class="timer-section" id="timerSection6">
        <h2>機能2: 繰り返し（10秒/15秒）</h2>
        <div class="status-display-container">
            <div class="current-status" id="status6"></div>
            <div class="next-beep-time" id="nextBeep6"></div>
            <div class="adjustment-info" id="adjustmentInfo6"></div>
        </div>
        <div class="timer-controls">
            <button class="adjust-button" onclick="adjustTimer(6, -0.1)">ー</button>
            <button onclick="startTimer2(6)">スタート</button>
            <button class="adjust-button" onclick="adjustTimer(6, 0.1)">＋</button>
            <button class="reset" onclick="resetTimer(6)">リセット</button>
        </div>
    </div>

    <div class="timer-section" id="timerSection7">
        <h2>機能3: 繰り返し（7.6秒/12.6秒）</h2>
        <div class="status-display-container">
            <div class="current-status" id="status7"></div>
            <div class="next-beep-time" id="nextBeep7"></div>
            <div class="adjustment-info" id="adjustmentInfo7"></div>
        </div>
        <div class="timer-controls">
            <button class="adjust-button" onclick="adjustTimer(7, -0.1)">ー</button>
            <button onclick="startTimer3(7)">スタート</button>
            <button class="adjust-button" onclick="adjustTimer(7, 0.1)">＋</button>
            <button class="reset" onclick="resetTimer(7)">リセット</button>
        </div>
    </div>

    <script>
        const timers = {
            1: { timeouts: [], intervals: [], startTime: null, nextBeepTimes: [], updateInterval: null, statusElement: null, nextBeepElement: null, sectionElement: null },
            2: { timeouts: [], intervals: [], startTime: null, nextBeepTimes: [], updateInterval: null, statusElement: null, nextBeepElement: null, sectionElement: null, adjustment: 0, adjustmentElement: null },
            3: { timeouts: [], intervals: [], startTime: null, nextBeepTimes: [], updateInterval: null, statusElement: null, nextBeepElement: null, sectionElement: null, adjustment: 0, adjustmentElement: null },
            4: { timeouts: [], intervals: [], startTime: null, nextBeepTimes: [], updateInterval: null, statusElement: null, nextBeepElement: null, sectionElement: null },
            6: { timeouts: [], intervals: [], startTime: null, nextBeepTimes: [], updateInterval: null, statusElement: null, nextBeepElement: null, sectionElement: null, adjustment: 0, adjustmentElement: null },
            7: { timeouts: [], intervals: [], startTime: null, nextBeepTimes: [], updateInterval: null, statusElement: null, nextBeepElement: null, sectionElement: null, adjustment: 0, adjustmentElement: null }
        };

        const ALL_TIMER_IDS = [1, 2, 3, 4, 6, 7];

        // 警告音を調整 (周波数を高く、短く)
        function playBeep() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.type = 'sine'; // 正弦波
                oscillator.frequency.setValueAtTime(880, audioContext.currentTime); // 周波数を880Hz (A5の音) に変更
                gainNode.gain.setValueAtTime(0.5, audioContext.currentTime); // 音量

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.08); // 0.08秒再生に短縮
            } catch (e) {
                console.error("音声の再生に失敗しました:", e);
            }
        }

        function resetTimer(timerId) {
            const timer = timers[timerId];
            if (!timer) return;

            timer.timeouts.forEach(timeoutId => clearTimeout(timeoutId));
            timer.intervals.forEach(intervalId => clearInterval(intervalId));
            if (timer.updateInterval) {
                clearInterval(timer.updateInterval);
            }

            timer.timeouts = [];
            timer.intervals = [];
            timer.startTime = null;
            timer.nextBeepTimes = [];
            timer.updateInterval = null;
            // adjustmentはリセットしない (累積させる)
            // if (timerId === 6 || timerId === 7) {
            //     timer.adjustment = 0; // 必要に応じてリセット
            // }

            updateStatus(timer.statusElement, '待機中', '#7f8c8d');
            updateNextBeepTime(timer.nextBeepElement, '', timerId);
            if (timer.adjustmentElement) {
                updateAdjustmentInfo(timer.adjustmentElement, timer.adjustment);
            }
            console.log(`機能${timerId}のタイマーがリセットされました。`);
        }

        function resetAllTimers() {
            ALL_TIMER_IDS.forEach(id => {
                const timer = timers[id];
                // 機能2と3のadjustmentはリセットしない
                if (id !== 6 && id !== 7) {
                     resetTimer(id);
                } else {
                     // 機能2と3は個別にリセット。adjustmentはそのまま
                     timer.timeouts.forEach(timeoutId => clearTimeout(timeoutId));
                     timer.intervals.forEach(intervalId => clearInterval(intervalId));
                     if (timer.updateInterval) {
                         clearInterval(timer.updateInterval);
                     }
                     timer.timeouts = [];
                     timer.intervals = [];
                     timer.startTime = null;
                     timer.nextBeepTimes = [];
                     timer.updateInterval = null;
                     updateStatus(timer.statusElement, '待機中', '#7f8c8d');
                     updateNextBeepTime(timer.nextBeepElement, '', id);
                     updateAdjustmentInfo(timer.adjustmentElement, timer.adjustment); // 調整値を再表示
                }
            });
            console.log('すべてのタイマーがリセットされました。');
        }

        function updateStatus(statusElement, message, color = '#3498db') {
            if (statusElement) {
                statusElement.textContent = message;
                statusElement.style.color = color;
            }
        }

        function updateNextBeepTime(element, nextBeepTimestamp, timerId) {
            if (!element) return;

            if (nextBeepTimestamp === '') {
                element.textContent = '';
                return;
            }

            const now = Date.now();
            let displayTime = '';
            let targetBeepTime = null;

            const allFutureBeeps = timers[timerId].nextBeepTimes.filter(t => t > now).sort((a,b) => a - b);

            if (timerId >= 1 && timerId <= 4) { // 機能1
                if (allFutureBeeps.length >= 2) {
                    targetBeepTime = allFutureBeeps[1];
                } else if (allFutureBeeps.length === 1) {
                    targetBeepTime = allFutureBeeps[0];
                }
            } else if (timerId === 6 || timerId === 7) { // 機能2, 3
                // adjustmentを考慮した110秒の基準点
                const initial110Beep = timers[timerId].startTime + (110 * 1000) + (timers[timerId].adjustment * 1000);

                if (now < initial110Beep && timers[timerId].startTime !== null) {
                    targetBeepTime = initial110Beep;
                } else {
                    if (allFutureBeeps.length >= 2) {
                        targetBeepTime = allFutureBeeps[1];
                    } else if (allFutureBeeps.length === 1) {
                        targetBeepTime = allFutureBeeps[0];
                    }
                }
            }

            if (targetBeepTime) {
                const remainingMs = targetBeepTime - now;
                const totalSeconds = Math.ceil(remainingMs / 1000);
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;

                const formattedMinutes = String(minutes).padStart(2, '0');
                const formattedSeconds = String(seconds).padStart(2, '0');
                displayTime = `${formattedMinutes}:${formattedSeconds}`;

                if (remainingMs <= 0) {
                    displayTime = '00:00';
                    element.style.color = '#000000';
                } else {
                    element.style.color = '#000000';
                }
            } else {
                displayTime = '';
            }
            element.textContent = displayTime;
        }

        // 誤差調整表示を更新
        function updateAdjustmentInfo(element, value) {
            if (element) {
                if (value === 0) {
                    element.textContent = '';
                } else {
                    element.textContent = `誤差調整: ${value.toFixed(1)}s`;
                    element.style.color = (value > 0) ? '#e74c3c' : '#2ecc71'; // 赤または緑
                }
            }
        }

        // 誤差調整関数
        function adjustTimer(timerId, amount) {
            const timer = timers[timerId];
            if (!timer || (timerId !== 6 && timerId !== 7)) return;

            timer.adjustment = parseFloat((timer.adjustment + amount).toFixed(1)); // 0.1秒単位で調整、小数点以下1桁に丸める
            updateAdjustmentInfo(timer.adjustmentElement, timer.adjustment);
            console.log(`機能${timerId}の誤差調整: ${timer.adjustment.toFixed(1)}s`);

            // タイマーが実行中の場合、現在時刻を補正して再スケジュール
            if (timer.startTime !== null) {
                // 現在の進行中のタイムアウトとインターバルをクリア
                timer.timeouts.forEach(timeoutId => clearTimeout(timeoutId));
                timer.intervals.forEach(intervalId => clearInterval(intervalId));
                timer.timeouts = [];
                timer.intervals = [];

                // 現在の経過時間を計算 (調整前の基準で)
                const elapsedSinceOriginalStart = Date.now() - timer.startTime;

                if (timerId === 6) { // 機能2
                    const initialDuration = 110; // 初回完了までの基本時間（110秒）
                    const cycleDuration = 15; // 1サイクルごとの基本時間（15秒）
                    const beep1Offset = 10; // サイクル内の1つ目の音のオフセット
                    const beep2Offset = 15; // サイクル内の2つ目の音のオフセット

                    // 110秒到達前の調整
                    if (elapsedSinceOriginalStart < (initialDuration * 1000)) {
                        // 105秒の音のスケジュール
                        const target105ms = (105 * 1000) + (timer.adjustment * 1000);
                        const remainingTo105 = target105ms - elapsedSinceOriginalStart;
                        if (remainingTo105 > 0) {
                            timer.timeouts.push(setTimeout(() => {
                                playBeep();
                                updateStatus(timer.statusElement, '105秒経過！');
                                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                                console.log(`機能${timerId}: 105秒後に音が鳴りました。`);
                                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
                            }, remainingTo105));
                        }

                        // 110秒の音のスケジュールとサイクル開始
                        const target110ms = (initialDuration * 1000) + (timer.adjustment * 1000);
                        const remainingTo110 = target110ms - elapsedSinceOriginalStart;
                        if (remainingTo110 > 0) {
                            timer.timeouts.push(setTimeout(() => {
                                playBeep();
                                updateStatus(timer.statusElement, '110秒経過！繰り返し開始。', '#3498db');
                                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                                console.log(`機能${timerId}: 110秒後に音が鳴りました。初回完了。`);
                                timer.nextBeepTimes = []; // 初回音は鳴り終わるのでクリア

                                // 最初のサイクル音をスケジュール
                                scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, timer.adjustment);

                                // 繰り返しインターバルを設定
                                const intervalId = setInterval(() => {
                                    scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, timer.adjustment);
                                }, (cycleDuration * 1000) + (timer.adjustment * 1000)); // インターバルも調整
                                timer.intervals.push(intervalId);
                            }, remainingTo110));
                        }

                        // nextBeepTimesも更新
                        timer.nextBeepTimes = [];
                        if (remainingTo105 > 0) timer.nextBeepTimes.push(Date.now() + remainingTo105);
                        if (remainingTo110 > 0) timer.nextBeepTimes.push(Date.now() + remainingTo110);
                        timer.nextBeepTimes.sort((a,b) => a - b);

                    } else {
                        // 110秒到達後の調整 (サイクル中の調整)
                        // 110秒経過時点からの相対時間
                        const elapsedSince110 = elapsedSinceOriginalStart - (initialDuration * 1000);
                        // 現在の調整値を考慮したサイクル時間
                        const adjustedCycleDurationMs = (cycleDuration * 1000) + (timer.adjustment * 1000);
                        // 現在のサイクル内の経過時間
                        const currentCycleElapsed = elapsedSince110 % adjustedCycleDurationMs;

                        // サイクル内の音のタイミングを調整値で補正
                        const adjustedBeep1OffsetMs = (beep1Offset * 1000) + (timer.adjustment * 1000);
                        const adjustedBeep2OffsetMs = (beep2Offset * 1000) + (timer.adjustment * 1000);

                        let nextBeepOffsetMs;
                        if (currentCycleElapsed < adjustedBeep1OffsetMs) {
                            // 1つ目の音がまだ鳴っていない場合
                            nextBeepOffsetMs = adjustedBeep1OffsetMs - currentCycleElapsed;
                        } else if (currentCycleElapsed < adjustedBeep2OffsetMs) {
                            // 2つ目の音がまだ鳴っていない場合
                            nextBeepOffsetMs = adjustedBeep2OffsetMs - currentCycleElapsed;
                        } else {
                            // 両方の音が鳴り終わっている場合、次のサイクルの1つ目の音まで
                            nextBeepOffsetMs = (adjustedCycleDurationMs - currentCycleElapsed) + adjustedBeep1OffsetMs;
                        }

                        // スケジュールを再設定
                        const scheduleFromNow = (offset, callback) => {
                            if (offset > 0) {
                                timer.timeouts.push(setTimeout(callback, offset));
                            } else {
                                // すでに過ぎている場合は即座に実行または次のサイクルに持ち越し
                                // ここでは単純化のため、過ぎていれば次のサイクルの対応する音の時間を計算
                            }
                        };

                        timer.nextBeepTimes = [];
                        const now = Date.now();

                        // 1つ目の音のスケジュール
                        const beep1AbsTime = now + nextBeepOffsetMs;
                        scheduleFromNow(nextBeepOffsetMs, () => {
                            playBeep();
                            updateStatus(timer.statusElement, `音1鳴動 (サイクルから${beep1Offset}秒)`);
                            setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                            console.log(`機能${timerId}: サイクルから${beep1Offset}秒後に音が鳴りました。`);
                            timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
                        });
                        timer.nextBeepTimes.push(beep1AbsTime);


                        // 2つ目の音のスケジュール (1つ目の音がまだ鳴っていなければ)
                        if (currentCycleElapsed < adjustedBeep1OffsetMs) {
                            const beep2OffsetFromNow = nextBeepOffsetMs + (adjustedBeep2OffsetMs - adjustedBeep1OffsetMs);
                             const beep2AbsTime = now + beep2OffsetFromNow;
                             scheduleFromNow(beep2OffsetFromNow, () => {
                                playBeep();
                                updateStatus(timer.statusElement, `音2鳴動 (サイクルから${beep2Offset}秒)`);
                                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                                console.log(`機能${timerId}: サイクルから${beep2Offset}秒後に音が鳴りました。`);
                                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
                            });
                            timer.nextBeepTimes.push(beep2AbsTime);
                        } else if (currentCycleElapsed < adjustedBeep2OffsetMs) {
                             // 1つ目の音は鳴ったが2つ目はまだの場合
                             const beep2OffsetFromNow = adjustedBeep2OffsetMs - currentCycleElapsed;
                             const beep2AbsTime = now + beep2OffsetFromNow;
                             scheduleFromNow(beep2OffsetFromNow, () => {
                                playBeep();
                                updateStatus(timer.statusElement, `音2鳴動 (サイクルから${beep2Offset}秒)`);
                                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                                console.log(`機能${timerId}: サイクルから${beep2Offset}秒後に音が鳴りました。`);
                                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
                            });
                            timer.nextBeepTimes.push(beep2AbsTime);
                        } else {
                            // 両方鳴り終わっている場合は次のサイクルの2つ目の音もスケジュール
                            const beep2OffsetFromNextCycleStart = nextBeepOffsetMs + (adjustedBeep2OffsetMs - adjustedBeep1OffsetMs);
                            const beep2AbsTime = now + beep2OffsetFromNextCycleStart;
                            timer.nextBeepTimes.push(beep2AbsTime);
                        }

                        timer.nextBeepTimes.sort((a,b) => a - b);

                        // メインのインターバルを再設定
                        if (timer.updateInterval) clearInterval(timer.updateInterval);
                        timer.updateInterval = setInterval(() => {
                            updateNextBeepTime(timer.nextBeepElement, '', timerId); // 次の音の表示を更新
                        }, 1000);

                        // サイクルを再開
                        const intervalId = setInterval(() => {
                            scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, timer.adjustment);
                        }, adjustedCycleDurationMs);
                        timer.intervals.push(intervalId);
                    }

                } else if (timerId === 7) { // 機能3
                    const initialDuration = 110;
                    const cycleDuration = 12.6;
                    const beep1Offset = 7.6;
                    const beep2Offset = 12.6;

                    // 110秒到達前の調整
                    if (elapsedSinceOriginalStart < (initialDuration * 1000)) {
                        const target105ms = (105 * 1000) + (timer.adjustment * 1000);
                        const remainingTo105 = target105ms - elapsedSinceOriginalStart;
                        if (remainingTo105 > 0) {
                            timer.timeouts.push(setTimeout(() => {
                                playBeep();
                                updateStatus(timer.statusElement, '105秒経過！');
                                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                                console.log(`機能${timerId}: 105秒後に音が鳴りました。`);
                                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
                            }, remainingTo105));
                        }

                        const target110ms = (initialDuration * 1000) + (timer.adjustment * 1000);
                        const remainingTo110 = target110ms - elapsedSinceOriginalStart;
                        if (remainingTo110 > 0) {
                            timer.timeouts.push(setTimeout(() => {
                                playBeep();
                                updateStatus(timer.statusElement, '110秒経過！繰り返し開始。', '#3498db');
                                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                                console.log(`機能${timerId}: 110秒後に音が鳴りました。初回完了。`);
                                timer.nextBeepTimes = [];

                                scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, timer.adjustment);

                                const intervalId = setInterval(() => {
                                    scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, timer.adjustment);
                                }, (cycleDuration * 1000) + (timer.adjustment * 1000));
                                timer.intervals.push(intervalId);
                            }, remainingTo110));
                        }

                        timer.nextBeepTimes = [];
                        if (remainingTo105 > 0) timer.nextBeepTimes.push(Date.now() + remainingTo105);
                        if (remainingTo110 > 0) timer.nextBeepTimes.push(Date.now() + remainingTo110);
                        timer.nextBeepTimes.sort((a,b) => a - b);

                    } else {
                        // 110秒到達後の調整 (サイクル中の調整)
                        const elapsedSince110 = elapsedSinceOriginalStart - (initialDuration * 1000);
                        const adjustedCycleDurationMs = (cycleDuration * 1000) + (timer.adjustment * 1000);
                        const currentCycleElapsed = elapsedSince110 % adjustedCycleDurationMs;

                        const adjustedBeep1OffsetMs = (beep1Offset * 1000) + (timer.adjustment * 1000);
                        const adjustedBeep2OffsetMs = (beep2Offset * 1000) + (timer.adjustment * 1000);

                        let nextBeepOffsetMs;
                        if (currentCycleElapsed < adjustedBeep1OffsetMs) {
                            nextBeepOffsetMs = adjustedBeep1OffsetMs - currentCycleElapsed;
                        } else if (currentCycleElapsed < adjustedBeep2OffsetMs) {
                            nextBeepOffsetMs = adjustedBeep2OffsetMs - currentCycleElapsed;
                        } else {
                            nextBeepOffsetMs = (adjustedCycleDurationMs - currentCycleElapsed) + adjustedBeep1OffsetMs;
                        }

                        const scheduleFromNow = (offset, callback) => {
                            if (offset > 0) {
                                timer.timeouts.push(setTimeout(callback, offset));
                            }
                        };

                        timer.nextBeepTimes = [];
                        const now = Date.now();

                        const beep1AbsTime = now + nextBeepOffsetMs;
                        scheduleFromNow(nextBeepOffsetMs, () => {
                            playBeep();
                            updateStatus(timer.statusElement, `音1鳴動 (サイクルから${beep1Offset}秒)`);
                            setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                            console.log(`機能${timerId}: サイクルから${beep1Offset}秒後に音が鳴りました。`);
                            timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
                        });
                        timer.nextBeepTimes.push(beep1AbsTime);

                        if (currentCycleElapsed < adjustedBeep1OffsetMs) {
                            const beep2OffsetFromNow = nextBeepOffsetMs + (adjustedBeep2OffsetMs - adjustedBeep1OffsetMs);
                             const beep2AbsTime = now + beep2OffsetFromNow;
                             scheduleFromNow(beep2OffsetFromNow, () => {
                                playBeep();
                                updateStatus(timer.statusElement, `音2鳴動 (サイクルから${beep2Offset}秒)`);
                                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                                console.log(`機能${timerId}: サイクルから${beep2Offset}秒後に音が鳴りました。`);
                                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
                            });
                            timer.nextBeepTimes.push(beep2AbsTime);
                        } else if (currentCycleElapsed < adjustedBeep2OffsetMs) {
                             const beep2OffsetFromNow = adjustedBeep2OffsetMs - currentCycleElapsed;
                             const beep2AbsTime = now + beep2OffsetFromNow;
                             scheduleFromNow(beep2OffsetFromNow, () => {
                                playBeep();
                                updateStatus(timer.statusElement, `音2鳴動 (サイクルから${beep2Offset}秒)`);
                                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                                console.log(`機能${timerId}: サイクルから${beep2Offset}秒後に音が鳴りました。`);
                                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
                            });
                            timer.nextBeepTimes.push(beep2AbsTime);
                        } else {
                            const beep2OffsetFromNextCycleStart = nextBeepOffsetMs + (adjustedBeep2OffsetMs - adjustedBeep1OffsetMs);
                            const beep2AbsTime = now + beep2OffsetFromNextCycleStart;
                            timer.nextBeepTimes.push(beep2AbsTime);
                        }
                        timer.nextBeepTimes.sort((a,b) => a - b);


                        if (timer.updateInterval) clearInterval(timer.updateInterval);
                        timer.updateInterval = setInterval(() => {
                            updateNextBeepTime(timer.nextBeepElement, '', timerId);
                        }, 1000);

                        const intervalId = setInterval(() => {
                            scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, timer.adjustment);
                        }, adjustedCycleDurationMs);
                        timer.intervals.push(intervalId);
                    }
                }
            }
        }


        function startTimer1(timerId) {
            const timer = timers[timerId];
            timer.statusElement = document.getElementById(`status${timerId}`);
            timer.nextBeepElement = document.getElementById(`nextBeep${timerId}`);
            timer.sectionElement = document.getElementById(`timerSection${timerId}`);

            resetTimer(timerId);

            timer.startTime = Date.now();
            updateStatus(timer.statusElement, 'タイマーを開始しました。');
            setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);

            const beep105Time = timer.startTime + (105 * 1000);
            const beep110Time = timer.startTime + (110 * 1000);
            timer.nextBeepTimes = [beep105Time, beep110Time].sort((a, b) => a - b);

            const timeout1 = setTimeout(() => {
                playBeep();
                updateStatus(timer.statusElement, '105秒経過！');
                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                console.log(`機能${timerId}: 105秒後に音が鳴りました。`);
                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
            }, 105 * 1000);

            const timeout2 = setTimeout(() => {
                playBeep();
                updateStatus(timer.statusElement, '110秒経過！完了。', '#2ecc71');
                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                console.log(`機能${timerId}: 110秒後に音が鳴りました。`);
                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
                if (timer.updateInterval) {
                     clearInterval(timer.updateInterval);
                     timer.updateInterval = null;
                }
            }, 110 * 1000);

            timer.timeouts.push(timeout1, timeout2);

            timer.updateInterval = setInterval(() => {
                const nextBeep = timer.nextBeepTimes.length > 0 ? timer.nextBeepTimes[0] : '';
                updateNextBeepTime(timer.nextBeepElement, nextBeep, timerId);
            }, 1000);
        }

        function scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, adjustment) {
            const timer = timers[timerId];
            const now = Date.now();
            const adjustedBeep1OffsetMs = (beep1Offset * 1000) + (adjustment * 1000);
            const adjustedBeep2OffsetMs = (beep2Offset * 1000) + (adjustment * 1000);

            const cycleBeep1Time = now + adjustedBeep1OffsetMs;
            const cycleBeep2Time = now + adjustedBeep2OffsetMs;

            timer.nextBeepTimes.push(cycleBeep1Time, cycleBeep2Time);
            timer.nextBeepTimes.sort((a, b) => a - b);

            const cycleTimeout1 = setTimeout(() => {
                playBeep();
                updateStatus(timer.statusElement, `音1鳴動 (サイクルから${beep1Offset}秒)`, '#f39c12');
                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                console.log(`機能${timerId}: サイクルから${beep1Offset}秒後に音が鳴りました。`);
                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
            }, adjustedBeep1OffsetMs);

            const cycleTimeout2 = setTimeout(() => {
                playBeep();
                updateStatus(timer.statusElement, `音2鳴動 (サイクルから${beep2Offset}秒)`, '#f39c12');
                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                console.log(`機能${timerId}: サイクルから${beep2Offset}秒後に音が鳴りました。`);
                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
            }, adjustedBeep2OffsetMs);
            timer.timeouts.push(cycleTimeout1, cycleTimeout2);
        }


        function startTimer2(timerId) {
            const timer = timers[timerId];
            timer.statusElement = document.getElementById(`status${timerId}`);
            timer.nextBeepElement = document.getElementById(`nextBeep${timerId}`);
            timer.sectionElement = document.getElementById(`timerSection${timerId}`);
            timer.adjustmentElement = document.getElementById(`adjustmentInfo${timerId}`);

            resetTimer(timerId); // これでadjustmentはリセットされない

            timer.startTime = Date.now();
            updateStatus(timer.statusElement, 'タイマーを開始しました。');
            setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);

            // 初期タイマーのタイミングに調整値を適用
            const initialBeep105Time = timer.startTime + (105 * 1000) + (timer.adjustment * 1000);
            const initialBeep110Time = timer.startTime + (110 * 1000) + (timer.adjustment * 1000);
            timer.nextBeepTimes = [initialBeep105Time, initialBeep110Time].sort((a, b) => a - b);

            const initialTimeout1 = setTimeout(() => {
                playBeep();
                updateStatus(timer.statusElement, '105秒経過！', '#3498db');
                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                console.log(`機能${timerId}: 105秒後に音が鳴りました。`);
                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
            }, initialBeep105Time - Date.now()); // 現在時刻からの相対時間

            const initialTimeout2 = setTimeout(() => {
                playBeep();
                updateStatus(timer.statusElement, '110秒経過！繰り返し開始。', '#3498db');
                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                console.log(`機能${timerId}: 110秒後に音が鳴りました。初回完了。`);
                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());

                const cycleDuration = 15;
                const beep1Offset = 10;
                const beep2Offset = 15;
                scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, timer.adjustment);

                const intervalId = setInterval(() => {
                    scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, timer.adjustment);
                }, (cycleDuration * 1000) + (timer.adjustment * 1000)); // インターバルにも調整値を適用
                timer.intervals.push(intervalId);

            }, initialBeep110Time - Date.now()); // 現在時刻からの相対時間

            timer.timeouts.push(initialTimeout1, initialTimeout2);

            timer.updateInterval = setInterval(() => {
                const nextBeep = timer.nextBeepTimes.length > 0 ? timer.nextBeepTimes[0] : '';
                updateNextBeepTime(timer.nextBeepElement, nextBeep, timerId);
            }, 1000);

            updateAdjustmentInfo(timer.adjustmentElement, timer.adjustment);
        }

        function startTimer3(timerId) {
            const timer = timers[timerId];
            timer.statusElement = document.getElementById(`status${timerId}`);
            timer.nextBeepElement = document.getElementById(`nextBeep${timerId}`);
            timer.sectionElement = document.getElementById(`timerSection${timerId}`);
            timer.adjustmentElement = document.getElementById(`adjustmentInfo${timerId}`);

            resetTimer(timerId);

            timer.startTime = Date.now();
            updateStatus(timer.statusElement, 'タイマーを開始しました。');
            setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);

            // 初期タイマーのタイミングに調整値を適用
            const initialBeep105Time = timer.startTime + (105 * 1000) + (timer.adjustment * 1000);
            const initialBeep110Time = timer.startTime + (110 * 1000) + (timer.adjustment * 1000);
            timer.nextBeepTimes = [initialBeep105Time, initialBeep110Time].sort((a, b) => a - b);

            const initialTimeout1 = setTimeout(() => {
                playBeep();
                updateStatus(timer.statusElement, '105秒経過！', '#3498db');
                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                console.log(`機能${timerId}: 105秒後に音が鳴りました。`);
                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());
            }, initialBeep105Time - Date.now());

            const initialTimeout2 = setTimeout(() => {
                playBeep();
                updateStatus(timer.statusElement, '110秒経過！繰り返し開始。', '#3498db');
                setTimeout(() => { updateStatus(timer.statusElement, ''); }, 1000);
                console.log(`機能${timerId}: 110秒後に音が鳴りました。初回完了。`);
                timer.nextBeepTimes = timer.nextBeepTimes.filter(t => t > Date.now());

                const cycleDuration = 12.6;
                const beep1Offset = 7.6;
                const beep2Offset = 12.6;
                scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, timer.adjustment);

                const intervalId = setInterval(() => {
                    scheduleCycleBeeps(timerId, cycleDuration, beep1Offset, beep2Offset, timer.adjustment);
                }, (cycleDuration * 1000) + (timer.adjustment * 1000));
                timer.intervals.push(intervalId);

            }, initialBeep110Time - Date.now());

            timer.timeouts.push(initialTimeout1, initialTimeout2);

            timer.updateInterval = setInterval(() => {
                const nextBeep = timer.nextBeepTimes.length > 0 ? timer.nextBeepTimes[0] : '';
                updateNextBeepTime(timer.nextBeepElement, nextBeep, timerId);
            }, 1000);

            updateAdjustmentInfo(timer.adjustmentElement, timer.adjustment);
        }


        // ページロード時に全てのタイマーの表示を初期化
        document.addEventListener('DOMContentLoaded', () => {
            ALL_TIMER_IDS.forEach(i => {
                const section = document.getElementById(`timerSection${i}`);
                if (section) {
                    if (i >= 1 && i <= 4) {
                        timers[i].statusElement = section.querySelector('.current-status');
                        timers[i].nextBeepElement = section.querySelector('.next-beep-time');
                    } else { // 機能2と3
                        const displayContainer = section.querySelector('.status-display-container');
                        timers[i].statusElement = displayContainer.querySelector('.current-status');
                        timers[i].nextBeepElement = displayContainer.querySelector('.next-beep-time');
                        timers[i].adjustmentElement = displayContainer.querySelector('.adjustment-info');
                    }
                    timers[i].sectionElement = section;
                    resetTimer(i);
                }
            });
        });
    </script>
</body>
</html>
